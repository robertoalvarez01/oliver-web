{"ast":null,"code":"//import {API} from '../config/index';\nimport { TRAER_PRODUCTOS, AGREGAR_PRODUCTO, ELIMINAR_PRODUCTO, LOADING, ERROR, CAMBIAR_MEDIO_DE_PAGO, CAMBIAR_COSTO_ENVIO } from '../types/carritoTypes';\nexport const traerProductos = () => async dispatch => {\n  dispatch({\n    type: LOADING\n  });\n\n  try {\n    const productos = await JSON.parse(localStorage.getItem('carrito'));\n    let total = 0;\n    productos.forEach(prd => {\n      total += parseInt(prd.precio * prd.cantidad);\n    });\n    let cantidad = productos.length;\n    let payloadData = {\n      productos,\n      total,\n      cantidad\n    };\n    return dispatch({\n      type: TRAER_PRODUCTOS,\n      payload: payloadData\n    });\n  } catch (error) {\n    return dispatch({\n      type: ERROR,\n      payload: error\n    });\n  }\n};\nexport const agregarProducto = producto => async (dispatch, getState) => {\n  dispatch({\n    type: LOADING\n  });\n\n  try {\n    //productos que hay en el reducer\n    let {\n      productos\n    } = getState().carritoReducer;\n    let listProductosUpgrade;\n    let productoRepetido = productos.filter(res => res.idSubProducto == producto.idSubProducto);\n\n    if (productoRepetido.length > 0) {\n      //si se intenta agregar de nuevo el mismo producto, se suma la cantidad, no todo el producto.\n      productoRepetido[0].cantidad = productoRepetido[0].cantidad + producto.cantidad;\n      let restantes = productos.filter(newRes => newRes.idSubProducto != productoRepetido[0].idSubProducto);\n\n      if (restantes.length > 0) {\n        listProductosUpgrade = [...restantes, productoRepetido[0]];\n      } else {\n        listProductosUpgrade = [productoRepetido[0]];\n      }\n    } else {\n      listProductosUpgrade = [...productos, producto];\n    } //actualizo localstorage\n\n\n    localStorage.setItem('carrito', JSON.stringify(listProductosUpgrade)); //calculo el subtotal\n\n    const prds = JSON.parse(localStorage.getItem('carrito'));\n    let total = 0;\n    prds.forEach(prd => {\n      total += parseInt(prd.precio * prd.cantidad);\n    });\n    let cantidad = listProductosUpgrade.length;\n    let payloadData = {\n      listProductosUpgrade,\n      total,\n      cantidad\n    };\n    setTimeout(() => {\n      dispatch({\n        type: AGREGAR_PRODUCTO,\n        payload: payloadData\n      });\n    }, 1500);\n  } catch (error) {\n    dispatch({\n      type: ERROR,\n      payload: error\n    });\n  }\n};\nexport const eliminarProducto = idSubProducto => async (dispatch, getState) => {\n  dispatch({\n    type: LOADING\n  });\n\n  try {\n    const {\n      productos\n    } = getState().carritoReducer; //filtro los productos que no tengan el idProducto que se recibió. entonces elimino ese producto y actualizo el reducer.\n\n    const newProductos = productos.filter(newArray => newArray.idSubProducto !== idSubProducto); //console.log(newProductos);\n\n    localStorage.setItem('carrito', JSON.stringify(newProductos)); //calculo el subtotal\n\n    const prds = JSON.parse(localStorage.getItem('carrito'));\n    let total = 0;\n    prds.forEach(prd => {\n      total += parseInt(prd.precio * prd.cantidad);\n    });\n    let payloadData = {\n      newProductos,\n      total,\n      cantidad: prds.length\n    };\n    dispatch({\n      type: ELIMINAR_PRODUCTO,\n      payload: payloadData\n    });\n  } catch (error) {\n    dispatch({\n      type: ERROR,\n      payload: error\n    });\n  }\n};\nexport const cambiarMedioDePago = idMedioDePago => dispatch => {\n  return dispatch({\n    type: CAMBIAR_MEDIO_DE_PAGO,\n    payload: idMedioDePago\n  });\n};\nexport const setCostoEnvio = costo => dispatch => {\n  return dispatch({\n    type: CAMBIAR_COSTO_ENVIO,\n    payload: costo\n  });\n};","map":{"version":3,"sources":["/home/franco/desarrollo/proyecto_oliver/oliver-web-next/store/actions/carritoActions.js"],"names":["TRAER_PRODUCTOS","AGREGAR_PRODUCTO","ELIMINAR_PRODUCTO","LOADING","ERROR","CAMBIAR_MEDIO_DE_PAGO","CAMBIAR_COSTO_ENVIO","traerProductos","dispatch","type","productos","JSON","parse","localStorage","getItem","total","forEach","prd","parseInt","precio","cantidad","length","payloadData","payload","error","agregarProducto","producto","getState","carritoReducer","listProductosUpgrade","productoRepetido","filter","res","idSubProducto","restantes","newRes","setItem","stringify","prds","setTimeout","eliminarProducto","newProductos","newArray","cambiarMedioDePago","idMedioDePago","setCostoEnvio","costo"],"mappings":"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","sourcesContent":["//import {API} from '../config/index';\nimport {TRAER_PRODUCTOS,AGREGAR_PRODUCTO,ELIMINAR_PRODUCTO,LOADING,ERROR, CAMBIAR_MEDIO_DE_PAGO, CAMBIAR_COSTO_ENVIO} from '../types/carritoTypes';\n\nexport const traerProductos = ()=>async (dispatch)=>{\n    dispatch({\n        type:LOADING\n    });\n    try {\n        const productos = await JSON.parse(localStorage.getItem('carrito'));\n        let total = 0;\n        productos.forEach(prd => {\n            total += parseInt(prd.precio * prd.cantidad);\n        });\n\n        let cantidad = productos.length;\n\n        let payloadData = {\n            productos,\n            total,\n            cantidad\n        }\n        return dispatch({\n            type:TRAER_PRODUCTOS,\n            payload:payloadData\n        });\n    } catch (error) {\n        return dispatch({\n            type:ERROR,\n            payload:error\n        })\n    }\n}\n\nexport const agregarProducto = producto=>async (dispatch,getState)=>{\n    dispatch({\n        type:LOADING\n    });\n    try {\n        //productos que hay en el reducer\n        let {productos} = getState().carritoReducer;\n        let listProductosUpgrade;\n        let productoRepetido = productos.filter(res=>res.idSubProducto==producto.idSubProducto);\n        if(productoRepetido.length>0){//si se intenta agregar de nuevo el mismo producto, se suma la cantidad, no todo el producto.\n            productoRepetido[0].cantidad = productoRepetido[0].cantidad + producto.cantidad;\n            let restantes = productos.filter(newRes=>newRes.idSubProducto!=productoRepetido[0].idSubProducto);\n            if(restantes.length>0){\n                listProductosUpgrade = [\n                    ...restantes,\n                    productoRepetido[0]\n                ];\n            }else{\n                listProductosUpgrade = [\n                    productoRepetido[0]\n                ];\n            }\n        }else{\n            listProductosUpgrade = [\n                ...productos,\n                producto\n            ];\n        }\n        //actualizo localstorage\n        localStorage.setItem('carrito',JSON.stringify(listProductosUpgrade));\n\n        //calculo el subtotal\n        const prds = JSON.parse(localStorage.getItem('carrito'));\n        let total = 0;\n        prds.forEach(prd => {\n            total += parseInt(prd.precio * prd.cantidad);\n        });\n        let cantidad = listProductosUpgrade.length;\n\n        let payloadData = {\n            listProductosUpgrade,\n            total,\n            cantidad\n        }\n        setTimeout(() => {\n            dispatch({\n                type:AGREGAR_PRODUCTO,\n                payload:payloadData\n            })\n        }, 1500);\n    } catch (error) {\n       dispatch({\n            type:ERROR,\n            payload:error\n        }) \n    }\n}\n\nexport const eliminarProducto = idSubProducto=>async (dispatch,getState)=>{\n    dispatch({\n        type:LOADING\n    });\n    try {\n        const {productos} = getState().carritoReducer;\n        //filtro los productos que no tengan el idProducto que se recibió. entonces elimino ese producto y actualizo el reducer.\n        const newProductos = productos.filter(newArray=>newArray.idSubProducto !== idSubProducto);\n\n        //console.log(newProductos);\n        localStorage.setItem('carrito',JSON.stringify(newProductos));\n\n        //calculo el subtotal\n        const prds = JSON.parse(localStorage.getItem('carrito'));\n        let total = 0;\n        prds.forEach(prd => {\n            total += parseInt(prd.precio * prd.cantidad);\n        });\n        \n        let payloadData = {\n            newProductos,\n            total,\n            cantidad:prds.length\n        }\n        dispatch({\n            type:ELIMINAR_PRODUCTO,\n            payload:payloadData\n        });\n    } catch (error) {\n        dispatch({\n            type:ERROR,\n            payload:error\n        })    \n    }\n}\n\nexport const cambiarMedioDePago = idMedioDePago =>dispatch=>{\n    return dispatch({\n        type:CAMBIAR_MEDIO_DE_PAGO,\n        payload:idMedioDePago\n    })\n}\n\nexport const setCostoEnvio = costo=>dispatch=>{\n    return dispatch({\n        type:CAMBIAR_COSTO_ENVIO,\n        payload:costo\n    })\n}"]},"metadata":{},"sourceType":"module"}